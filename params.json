{"name":"Icecast2-php-api","tagline":"A powerful and flexible REST API for IceCast2 written in PHP","body":"# IceCast2 PHP API\r\n\r\n## Overview\r\nThis is fully functional, easy-to-use, RESTful API interface for your icecast2-based radio station.\r\nIt's based on a popular Slim Framework which makes it very flexible and reliable solution.\r\n\r\nFeatues:\r\n* Easy to configure.\r\n* Integration with memcached for high performance.\r\n* Rapid deployment within a minute.\r\n* Multiple mountpoint support!\r\n* Easy to extend.\r\n* Different response types: JSON or XML.\r\n* Mount fallback support!\r\n* It is awesome!\r\n\r\nIt allows you to:\r\n* Show number of listeners per mountpoint.\r\n* Show current track per mountpoint with timestamp.\r\n* Show last N tracks per mountpoiint alwo with their timestamps.\r\n* Show total number of current listeners online.\r\n* Show album art via GraceNote for current track.\r\n\r\n## Install\r\nIt's never been so easy if you're using composer.\r\nJust unpack it to your api's root directory, and install the dependencies:\r\n\r\n```php composer.phar install```\r\n\r\n## Configuration\r\nAfter all dependencies are installed, it's the time to configure our new API.\r\nWell, it's pretty simple, just edit the $config array:\r\n```\r\n//IceCast API Config\r\n$config = array(\r\n\t'icecast_server_hostname' \t\t => 'radio.example.com', //icecast2 server hostname or IP\r\n\t'icecast_server_port'\t\t\t => 80, \r\n\t'icecast_admin_username' \t\t => 'admin', //admin username\r\n\t'icecast_admin_password' \t     => 'hackme', //admin password\r\n\t\r\n\t\r\n\t//unused\r\n\t'icecast_listener_auth_header_title'\t\t\t=> 'icecast-auth-user',\r\n\t'icecast_listener_auth_header_value'\t\t\t=> '1',\r\n\t'icecast_listener_auth_header_reject_reason' \t=> 'Rejected',\r\n\t\r\n\t//If you have an event based mounts(e.g. for live broadcasting), \r\n\t//you should configure fallback map below according to your icecast2 config file.\r\n\t//Read the docs for more info.\r\n\t'icecast_mount_fallback_map' => array('live' => 'nonstop',  // from => to\r\n\t\t\t\t\t\t\t\t\t  'trance'  => 'trance.nonstop',\r\n\t\t\t\t\t\t\t\t\t  'house'\t=> 'house.nonstop'),\r\n\t\t\t\t\t\t\t\t\t  \r\n\t'playlist_logfile' \t\t => '/var/log/icecast2/playlist.log', // must be available for reading\r\n\t\r\n\t'use_memcached' \t\t => false, // Enable memcached support: true | false\r\n\t'use_db'\t\t\t\t => false, // Enable db support: true | false  (unused atm)\r\n\r\n\t'memcached' \t\t\t => array('host' \t\t=> '127.0.0.1', \r\n\t\t\t\t\t\t\t\t\t  'port' \t\t=> 11211, \r\n\t\t\t\t\t\t\t\t\t  'lifetime' \t=> 5, // lifetime of the cache in seconds\r\n\t\t\t\t\t\t\t\t\t  'compressed'  => 0), // compress data stored with memcached? 1 or 0. Requires zlib.\r\n\t\t\t\t\t\t\t\t\t  \r\n\t'db'\t\t\t\t\t=> array('host'\t\t\t=> '127.0.0.1',\r\n\t\t\t\t\t\t\t\t\t 'port'\t\t\t=> 3306,\r\n\t\t\t\t\t\t\t\t\t 'user'\t\t\t=> 'dbuser',\r\n\t\t\t\t\t\t\t\t\t 'password'\t\t=> 'dbpassword'),\t\t\t\r\n\t'max_amount_of_history'\t => '20', // max limit of requested items of playback history\r\n\t'xmlrootnode'\t\t\t => 'response', // Root node name for the response using XML.\r\n\t'album_art_folder'\t\t => getcwd().'/storage/albums/',   // cache folder for albums art images. With trailing slash. Normally, u shouldn't change this.\r\n\t'gracenote'\t\t\t\t => array('clientID' \t=> '',\r\n\t\t\t\t\t\t\t\t\t  'clientTag' \t=> '',\r\n\t\t\t\t\t\t\t\t\t  'userID' \t\t=> '',\r\n\t\t\t\t\t\t\t\t),\r\n\t'default_storage_folder' => getcwd().'/storage/default/', // default static folder. Normally, u shouldn't change this.\r\n);\r\n\r\n```\r\n## Mount Fallback map\r\nI think every popular radiostation hosts a live broadcasts. But with all it's popularity, it comes with some problems, if you're using default Icecast2 fallback mechanic.\r\nWhen live source hits the air, listeners are being automatically moved to its mountpoint, leaving the old nonstop mount completely empty.\r\nIn order to continue providing actual data to your API clients you need to detect when live broadcast is going up and alter your data \"on-the-fly\".\r\n\r\nTo bring this thing to work you need to configure Mount Fallback map according to your station's archeticture.\r\n\r\nSo, for example, if you have live(for DJs) mount called \"live\" with following configuration in icecast.xml:\r\n```\r\n<mount>\r\n  <mount-name>/live</mount-name>\r\n\t<stream-name>MyRadio Main RJ Stream</stream-name>\r\n  <fallback-mount>/myradio.nonstop</fallback-mount>\r\n\t<fallback-override>1</fallback-override>\r\n\t<mp3-metadata-interval>2048</mp3-metadata-interval>\r\n\t<password>pwd</password>\r\n</mount>\r\n```\r\nJust bring the `icecast_mount_fallback_map` to the following state:\r\n```\r\n'icecast_mount_fallback_map'   => array('live' => 'myradio.nonstop'),\r\n```\r\nThat' all. Now your API service will provide data from the live mount when it's active or from the one it's associated with, if it's down.\r\n\r\n\r\n## Getting an album and artist art from Gracenote for your current track\r\nNow, this API also allows you to show an album cover wherever you want. But, you have to do some steps in order to setup this feature.\r\n* First, go to https://developer.gracenote.com/ and make yourself an account if dont have one.\r\n* After creating your application, gracenote will provide you with clientTag and clientID.\r\n* Add them to your config file and launch yourapihost.com/gracenote-php/register.php . \r\n* If everything went OK, you should get your userID key. Save it to your config file.\r\nThat's it. \r\nFor example, you can try requesting youapihost.com/cover/Nickelback/Lullaby for album image, and youapihost.com/cover/Nickelback for artist image.\r\n\r\nDont forget to make storage folders writable.\r\nAlso note, that when album cover image is pulled from gracenote' api for the first time, API then saves it on the filesystem, making subsequent request on same image much faster.\r\n\r\n## Performance\r\nThanks to built-in memcached support your new api service has, quite literally,  unrival performance.\r\n\r\nHere are some tests result:\r\n\r\nQuery: `ab -n 10000 -c 100 http://api.example.com/radio/live/history/7/xml/\r\n\r\n### Memcached OFF\r\n```\r\n\tServer Software:        nginx/0.7.67\r\n\t\r\n\tDocument Path:          /radio/live/history/7/xml/\r\n\tDocument Length:        697 bytes\r\n\t\r\n\tConcurrency Level:      100\r\n\tTime taken for tests:   24.540 seconds\r\n\tComplete requests:      10000\r\n\tFailed requests:        0\r\n\tWrite errors:           0\r\n\tTotal transferred:      25380000 bytes\r\n\tHTML transferred:       23410000 bytes\r\n\tRequests per second:    407.49 [#/sec] (mean)\r\n\tTime per request:       245.405 [ms] (mean)\r\n\tTime per request:       2.454 [ms] (mean, across all concurrent requests)\r\n\tTransfer rate:          1009.97 [Kbytes/sec] received\r\n```\r\n### Memcached ON\r\n```\r\n\tServer Software:        nginx/0.7.67\r\n\t\r\n\tDocument Path:           /radio/live/history/7/xml/\r\n\tDocument Length:        682 bytes\r\n\t\r\n\r\n\tConcurrency Level:      100\r\n\tTime taken for tests:   6.134 seconds\r\n\tComplete requests:      10000\r\n\tFailed requests:        0\r\n\tWrite errors:           0\r\n\tTotal transferred:      25380000 bytes\r\n\tHTML transferred:       23410000 bytes\r\n\tRequests per second:    1630.16 [#/sec] (mean)\r\n\tTime per request:       61.344 [ms] (mean)\r\n\tTime per request:       0.613 [ms] (mean, across all concurrent requests)\r\n\tTransfer rate:          4040.39 [Kbytes/sec] received\r\n```\r\n\r\nAll tests were made on the following server:\r\n```\r\nCPU\tIntel Quad Xeon E3-1230 4 x 3.20 Ghz\r\nRAM\t12 GB\r\nWeb-server: nginx 0.7 with php5-fpm\r\n```\r\n1630 RPS against 407.\r\nNot bad, huh? Whatcha think?\r\n\r\n\r\n## Demos\r\nSo, the best demo is the working project, right?\r\nThis API is fully integrated and succesfuly working at the most popular russian \r\nonline gaming station called \"Tort.FM\". It was developed for that project, eventually.\r\n\r\nHere you go:\r\n### Current listeners from tort.fm main mountpoint, xml response:\r\n<http://api.tort.fm/radio/tort.fm/listeners/xml/>\r\n### Current track from tort.fm main mountpoint, json response:\r\n<http://api.tort.fm/radio/tort.fm/song/json/>\r\n### Last 7 tracks from our trance channel, xml response:\r\n<http://api.tort.fm/radio/tort.fm/history/7/xml/>\r\n### Total listeners, xml response:\r\n<http://api.tort.fm/radio/TotalListeners/xml/>\r\n### Album art, jpg response:\r\n<http://api.tort.fm/radio/cover/Nickelback/Lullaby/>\r\n### Artist art, jpg response:\r\n<http://api.tort.fm/radio/cover/Nickelback/>\r\n\r\n## Extend\r\nIf you want to add your custom functionality, just create additional methods in icecast_api.php file using this template:\r\n```\r\nprivate function YourCustomMethodAction(array $args){\r\n\t\treturn array('Hello' => 'Im a template for your custom methods.');\r\n} \r\n```\r\nNote: There is a strict rules applied to the names of your methods. It has to have the following format: {methodname}Action.\r\n\r\nThen create new route block inside index.php file like this:\r\n```\r\n$app->get('/customMethod/:variable/:responseType(/)', function ($variable, $responseType) use ($icecastApi, $app) {\r\n\r\n  $app->response()->header(\"Content-Type\", \"application/\".$responseType);\r\n  echo $icecastApi->Request('YourCustomMethod',array('your_var' => $variable))->Response($responseType);\r\n\t\r\n})->conditions(array(\"responseType\" => \"(json|xml)\"));\r\n```\r\nThis is it. You can find these templates within the files aswell.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}